<style>
    #canvas{
        border: 1px solid black;
    }
</style>
<div class="grid-x">
    <canvas id="canvas"></canvas>
</div>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    var BB = canvas.getBoundingClientRect();
    var offsetX = BB.left;
    var offsetY = BB.top;
    canvas.width = 800;
    canvas.height = 500;
    var WIDTH = canvas.width;
    var HEIGHT = canvas.height;

    var dragok = false;
    var startX;
    var startY;
    var rects = [];
    // var pos   = [];

    const doing = {
        dimention: async function() {
            WIDTH = 2200;
            HEIGHT = 800;
        },
        init: async function() {
            doing.clear();
            // doing.move(0, 0, WIDTH, HEIGHT);

            // redraw each rect in the rects[] array
            for (const rect of rects) {
                // ctx.fillStyle = rect.fill;
                doing.move(rect.image, rect.x, rect.y, rect.w, rect.h, rect.isSelect);
                // pos[rect] = ctx.save();
            }
        },
        clear: async function() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
        },
        move: async function(img, x, y, w, h, isSelect) {
            ctx.drawImage(img, x, y, w, h);

            if (isSelect) {
                ctx.beginPath();
                ctx.fillStyle = '#00000002';
                ctx.fillRect(x, y, w, h);
                ctx.closePath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#99d2ee";
                ctx.strokeRect(x, y, w, h);
            }
        },
        mouseDown: async function(e) {
            // tell the browser we're handling this mouse event
            e.preventDefault();
            e.stopPropagation();

            // get the current mouse position
            var mx = parseInt(e.clientX - offsetX);
            var my = parseInt(e.clientY - offsetY);

            // test each rect to see if mouse is inside
            dragok = false;
            
            for (const rect of rects) {
                rect.isSelect = false;
                doing.mouseUnselected(rect);

                if (mx > rect.x && mx < rect.x + rect.w && my > rect.y && my < rect.y + rect.h) {
                    dragok = true;
                    rect.isDragging = true;
                    doing.mouseSelected(rect);
                    rect.isSelect = true;
                }
            }
            
            // save the current mouse position
            startX = mx;
            startY = my;
        },
        mouseMove: async function(e) {
            // if we're dragging anything...
            if (dragok) {
                // tell the browser we're handling this mouse event
                e.preventDefault();
                e.stopPropagation();
                
                // get the current mouse position
                var mx = parseInt(e.clientX - offsetX);
                var my = parseInt(e.clientY - offsetY);

                // calculate the distance the mouse has moved
                // since the last mousemove
                var dx = mx - startX;
                var dy = my - startY;

                // move each rect that isDragging 
                // by the distance the mouse has moved
                // since the last mousemove
                for (const rect of rects) {
                    if (rect.isDragging) {
                        rect.x += dx;
                        rect.y += dy;
                    }
                }
                
                // redraw the scene with the new rect positions
                doing.init();

                // reset the starting mouse position for the next mousemove
                startX = mx;
                startY = my;

            }
        },
        mouseUp: async function(e) {
            // tell the browser we're handling this mouse event
            e.preventDefault();
            e.stopPropagation();

            // clear all the dragging flags
            dragok = false;
            for (const rect of rects) {
                rect.isDragging = false;
            }
        },
        mouseSelected: function(rect) {
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#99d2ee";
            ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        },
        mouseUnselected: function (rect) {
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ffffff";
            ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        }
    }

    $(document).ready(async function() {
        // doing.dimention();
        
        return new Promise((resolve, reject) => {
            let img = new Image()
            img.onload = () => resolve(load(img))
            img.onerror = reject
            img.src = './Pomeranian 3.png';
        });

        function load(img) {
            rects.push({
                x: 10,
                y: 5,
                w: img.naturalWidth,
                h: img.naturalHeight,
                image: img,
                isSelect: false,
                // fill: "#444444",
                isDragging: false
            });

            rects.push({
                x: 200,
                y: 5,
                w: img.naturalWidth,
                h: img.naturalHeight,
                image: img,
                isSelect: false,
                // fill: "#ff550d",
                isDragging: false
            }); 

            rects.push({
                x: 300,
                y: 5,
                w: img.naturalWidth,
                h: img.naturalHeight,
                image: img,
                isSelect: false,
                // fill: "#ff550d",
                isDragging: false
            }); 
            canvas.onmousedown = function(e) {
                doing.mouseDown(e);
            }
            canvas.onmouseup = function(e) {
                doing.mouseUp(e);
            }
            canvas.onmousemove = function(e) {
                doing.mouseMove(e);
            }

            doing.init();
        }
    });
</script>